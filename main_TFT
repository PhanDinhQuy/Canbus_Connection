/* USER CODE BEGIN Header */
/**
 ******************************************************************************
 * @file           : main.c
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2025 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */
/* USER CODE END Header */
/* Includes ------------------------------------------------------------------*/
#include "main.h"
/* Private includes ----------------------------------------------------------*/
/* USER CODE BEGIN Includes */
#include "lvgl.h"
#include "LCDController.h"
#include "demos/benchmark/lv_demo_benchmark.h"
#include "ili9486_lvgl.h"
#include "ui.h"
#include <stdio.h>
/* USER CODE END Includes */
/* Private typedef -----------------------------------------------------------*/
/* USER CODE BEGIN PTD */
/* (none) */
/* USER CODE END PTD */
/* Private define ------------------------------------------------------------*/
/* USER CODE BEGIN PD */
/* (none) */
/* USER CODE END PD */
/* Private macro -------------------------------------------------------------*/
/* USER CODE BEGIN PM */
/* (none) */
/* USER CODE END PM */
/* Private variables ---------------------------------------------------------*/
CAN_HandleTypeDef hcan2;
RTC_HandleTypeDef hrtc;
SPI_HandleTypeDef hspi1;
DMA_HandleTypeDef hdma_spi1_tx;
TIM_HandleTypeDef htim2;
/* USER CODE BEGIN PV */
uint32_t angle_to_pulse(uint8_t angle) {
   const uint32_t min = 1000, max = 2000;
   if (angle > 180) angle = 180;
   return min + ((uint32_t)angle * (max - min)) / 180;
}
CAN_RxHeaderTypeDef RxHeader;
uint8_t             RxData[8];
float    CO2_ppm               = 0.0f;
uint8_t  air_quality_category = 0;
// Flag báo có dữ liệu CO2 mới từ ISR
volatile bool flag_new_co2 = false;
volatile bool new_temp_frame = false;
volatile bool new_pres_frame = false;
uint8_t value1 = 50;
uint8_t value2 = 50;
uint8_t temp1  = 20;
uint8_t temp2  = 20;
uint32_t delayCounter = 0;
bool blink1 = false;
bool blink2 = false;
bool blinkCO2 = false;
// Lưu giá trị CO2 cuối cùng đã hiển thị (nguyên)
static int last_displayed_co2 = -1;
float temp_sensor1;
float temp_sensor2;
float pres_sensor1;
float pres_sensor2;
/* USER CODE END PV */
/* Private function prototypes -----------------------------------------------*/
void SystemClock_Config(void);
static void MX_GPIO_Init(void);
static void MX_DMA_Init(void);
static void MX_SPI1_Init(void);
static void MX_RTC_Init(void);
static void MX_CAN2_Init(void);
static void MX_TIM2_Init(void);
/* USER CODE BEGIN PFP */
// Prototype for CAN RX callback
void HAL_CAN_RxFifo0MsgPendingCallback(CAN_HandleTypeDef *hcan);
/* USER CODE END PFP */
/* Private user code ---------------------------------------------------------*/
/* USER CODE BEGIN 0 */
/* (none) */
/* USER CODE END 0 */
/**
 * @brief  The application entry point.
 * @retval int
 */
int main(void)
{
 /* USER CODE BEGIN 1 */
 /* (none) */
 /* USER CODE END 1 */
 /* MCU Configuration--------------------------------------------------------*/
 /* Reset of all peripherals, Initializes the Flash interface and the Systick. */
 HAL_Init();
 /* USER CODE BEGIN Init */
 /* (none) */
 /* USER CODE END Init */
 /* Configure the system clock */
 SystemClock_Config();
 /* USER CODE BEGIN SysInit */
 /* (none) */
 /* USER CODE END SysInit */
 /* Initialize all configured peripherals */
 MX_GPIO_Init();
 MX_DMA_Init();
 MX_SPI1_Init();
 MX_RTC_Init();
 MX_CAN2_Init();
 MX_TIM2_Init();
 /* USER CODE BEGIN 2 */
 HAL_TIM_PWM_Start(&htim2, TIM_CHANNEL_1);
   HAL_TIM_PWM_Start(&htim2, TIM_CHANNEL_2);
 /* Start CAN2 and enable RX interrupt on FIFO0 */
 if (HAL_CAN_Start(&hcan2) != HAL_OK) {
   Error_Handler();
 }
 if (HAL_CAN_ActivateNotification(&hcan2, CAN_IT_RX_FIFO0_MSG_PENDING) != HAL_OK) {
   Error_Handler();
 }
 lv_init();
 lv_port_disp_init();
 ui_init();          // Initialize SquareLine UI
 // Initial label values
 lv_label_set_text(ui_value1, "50");
 lv_label_set_text(ui_value2, "50");
 lv_label_set_text(ui_temp1, "20°C");
 lv_label_set_text(ui_temp2, "20°C");
 lv_label_set_text(ui_CO2val, "100");
 // Initial visibility
 lv_obj_clear_flag(ui_wheelfine1, LV_OBJ_FLAG_HIDDEN);
 lv_obj_clear_flag(ui_wheelfine2, LV_OBJ_FLAG_HIDDEN);
 lv_obj_clear_flag(ui_wheelfine3, LV_OBJ_FLAG_HIDDEN);
 lv_obj_clear_flag(ui_wheelfine4, LV_OBJ_FLAG_HIDDEN);
 lv_obj_add_flag(ui_wheelwarning1, LV_OBJ_FLAG_HIDDEN);
 lv_obj_add_flag(ui_wheelwarning2, LV_OBJ_FLAG_HIDDEN);
 lv_obj_add_flag(ui_Image11, LV_OBJ_FLAG_HIDDEN); // ui_Image11 asset
 /* USER CODE END 2 */
 /* Infinite loop */
 /* USER CODE BEGIN WHILE */
 while (1)
 {
   lv_timer_handler();
   HAL_Delay(5);
   delayCounter++;
   // Nếu có dữ liệu CO2 mới, cập nhật label (chỉ khi số nguyên thay đổi)
   if (flag_new_co2) {
     flag_new_co2 = false;
     int co2_int = (int)CO2_ppm;
     // Giới hạn hiển thị CO2 trong khoảng 0..2100 (nếu cần)
     if (co2_int < 0) co2_int = 0;
     if (co2_int > 2100) co2_int = 2100;
     if (co2_int != last_displayed_co2) {
       last_displayed_co2 = co2_int;
       char buf[16];
       snprintf(buf, sizeof(buf), "%d", co2_int);
       lv_label_set_text(ui_CO2val, buf);
     }
   }
   if (new_temp_frame && new_pres_frame) {
     new_temp_frame = false;
     new_pres_frame = false;
     // Hiển thị nhiệt độ lên ui_temp1 và ui_temp2
     char bufT1[16], bufT2[16];
     snprintf(bufT1, sizeof(bufT1), "%d°C", (int)temp_sensor1);
     snprintf(bufT2, sizeof(bufT2), "%d°C", (int)temp_sensor2);
     lv_label_set_text(ui_temp1, bufT1);
     lv_label_set_text(ui_temp2, bufT2);
     // Hiển thị áp suất lên ui_value1 và ui_value2
     char bufP1[16], bufP2[16];
     float psi1 = pres_sensor1 / 6894.757f;
     float psi2 = pres_sensor2 / 6894.757f;
     snprintf(bufP1, sizeof(bufP1), "%d", (int)psi1);
     snprintf(bufP2, sizeof(bufP2), "%d", (int)psi2);
     lv_label_set_text(ui_value1, bufP1);
     lv_label_set_text(ui_value2, bufP2);
   }
   // Handle blinking and visibility for value1
   if (value1 < 15) {
     lv_obj_clear_flag(ui_wheelfine1, LV_OBJ_FLAG_HIDDEN);
     lv_obj_add_flag(ui_wheelwarning1, LV_OBJ_FLAG_HIDDEN);
   } else {
     if (delayCounter % 50 == 0) {
       blink1 = !blink1;
       if (blink1) {
         lv_obj_clear_flag(ui_wheelwarning1, LV_OBJ_FLAG_HIDDEN);
         lv_obj_add_flag(ui_wheelfine1, LV_OBJ_FLAG_HIDDEN);
       } else {
         lv_obj_add_flag(ui_wheelwarning1, LV_OBJ_FLAG_HIDDEN);
       }
     }
   }
   // Handle blinking and visibility for value2
   if (value2 < 15) {
     lv_obj_clear_flag(ui_wheelfine2, LV_OBJ_FLAG_HIDDEN);
     lv_obj_add_flag(ui_wheelwarning2, LV_OBJ_FLAG_HIDDEN);
   } else {
     if (delayCounter % 50 == 0) {
       blink2 = !blink2;
       if (blink2) {
         lv_obj_clear_flag(ui_wheelwarning2, LV_OBJ_FLAG_HIDDEN);
         lv_obj_add_flag(ui_wheelfine2, LV_OBJ_FLAG_HIDDEN);
       } else {
         lv_obj_add_flag(ui_wheelwarning2, LV_OBJ_FLAG_HIDDEN);
       }
     }
   }
   // Handle blinking for CO2 warning image (ui_Image11)
   if (CO2_ppm >= 500.0f) {
     // Nếu lần đầu vừa vượt ngưỡng, bật visible ngay
     if (!blinkCO2) {
       blinkCO2 = true;
       lv_obj_clear_flag(ui_Image11, LV_OBJ_FLAG_HIDDEN);
     }
     for (uint8_t a = 0; a <= 180; a += 5) {
     	      __HAL_TIM_SET_COMPARE(&htim2, TIM_CHANNEL_1, angle_to_pulse(a));
     	      __HAL_TIM_SET_COMPARE(&htim2, TIM_CHANNEL_2, angle_to_pulse(a));
     	      HAL_Delay(50);
     }
     // Mỗi khi delayCounter % 50 == 0, toggle trạng thái
     if (delayCounter % 50 == 0) {
       blinkCO2 = !blinkCO2;
       if (blinkCO2) {
         lv_obj_clear_flag(ui_Image11, LV_OBJ_FLAG_HIDDEN);
       } else {
         lv_obj_add_flag(ui_Image11, LV_OBJ_FLAG_HIDDEN);
       }
     }
   }
   else {
     blinkCO2 = false;
     lv_obj_add_flag(ui_Image11, LV_OBJ_FLAG_HIDDEN);
   }
 }
   /* USER CODE END WHILE */
   /* USER CODE BEGIN 3 */
}
 /* USER CODE END 3 */
/**
 * @brief CAN2 RX FIFO0 message pending callback
 * @param hcan: CAN handle pointer
 */
void HAL_CAN_RxFifo0MsgPendingCallback(CAN_HandleTypeDef *hcan)
{
 // 1) Lấy message từ FIFO0
 if (HAL_CAN_GetRxMessage(hcan, CAN_RX_FIFO0, &RxHeader, RxData) != HAL_OK) {
   Error_Handler();
 }
 // 2) Phân ID
 switch (RxHeader.StdId) {
   case 0x123: {
     // ========== Frame CO2 ==========
     uint16_t raw = (RxData[0] << 8) | RxData[1];
     CO2_ppm = raw / 100.0f;
     air_quality_category = RxData[2];
     flag_new_co2 = true;
     break;
   }
   case 0x124: {
     int16_t ti1 = (int16_t)((RxData[0] << 8) | RxData[1]);
     int16_t ti2 = (int16_t)((RxData[2] << 8) | RxData[3]);
     temp_sensor1 = ti1 / 100.0f;
     temp_sensor2 = ti2 / 100.0f;
     new_temp_frame = true;       // Đánh dấu đã có dữ liệu nhiệt độ mới
     break;
   }
   case 0x125: {
     uint16_t pi1 = (uint16_t)((RxData[0] << 8) | RxData[1]);
     uint16_t pi2 = (uint16_t)((RxData[2] << 8) | RxData[3]);
     pres_sensor1 = pi1 * 100.0f;
     pres_sensor2 = pi2 * 100.0f;
     new_pres_frame = true;      // Đánh dấu đã có dữ liệu áp suất mới
     break;
   }
   default:
     // Bỏ qua các ID khác
     break;
 }
}
/**
 * @brief System Clock Configuration
 * @retval None
 */
void SystemClock_Config(void)
{
 RCC_OscInitTypeDef RCC_OscInitStruct = {0};
 RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
 /** Configure the main internal regulator output voltage
 */
 __HAL_RCC_PWR_CLK_ENABLE();
 __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
 /** Initializes the RCC Oscillators according to the specified parameters
 * in the RCC_OscInitTypeDef structure.
 */
 RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI|RCC_OSCILLATORTYPE_HSE;
 RCC_OscInitStruct.HSEState = RCC_HSE_ON;
 RCC_OscInitStruct.HSIState = RCC_HSI_ON;
 RCC_OscInitStruct.HSICalibrationValue = RCC_HSICALIBRATION_DEFAULT;
 RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
 RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSI;
 RCC_OscInitStruct.PLL.PLLM = 8;
 RCC_OscInitStruct.PLL.PLLN = 64;
 RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
 RCC_OscInitStruct.PLL.PLLQ = 4;
 if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
 {
   Error_Handler();
 }
 /** Initializes the CPU, AHB and APB buses clocks
 */
 RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
                             |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
 RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
 RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
 RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV2;
 RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV2;
 if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_2) != HAL_OK)
 {
   Error_Handler();
 }
}
/**
 * @brief CAN2 Initialization Function
 * @param None
 * @retval None
 */
static void MX_CAN2_Init(void)
{
 /* USER CODE BEGIN CAN2_Init 0 */
	  CAN_FilterTypeDef sFilterConfig;
 /* USER CODE END CAN2_Init 0 */
 /* USER CODE BEGIN CAN2_Init 1 */
 /* USER CODE END CAN2_Init 1 */
 hcan2.Instance = CAN2;
 hcan2.Init.Prescaler = 4;
 hcan2.Init.Mode = CAN_MODE_NORMAL;
 hcan2.Init.SyncJumpWidth = CAN_SJW_1TQ;
 hcan2.Init.TimeSeg1 = CAN_BS1_12TQ;
 hcan2.Init.TimeSeg2 = CAN_BS2_3TQ;
 hcan2.Init.TimeTriggeredMode = DISABLE;
 hcan2.Init.AutoBusOff = DISABLE;
 hcan2.Init.AutoWakeUp = DISABLE;
 hcan2.Init.AutoRetransmission = DISABLE;
 hcan2.Init.ReceiveFifoLocked = DISABLE;
 hcan2.Init.TransmitFifoPriority = DISABLE;
 if (HAL_CAN_Init(&hcan2) != HAL_OK)
 {
   Error_Handler();
 }
 /* USER CODE BEGIN CAN2_Init 2 */
 /* Configure filter to accept ALL IDs (Mask = 0) */
 sFilterConfig.FilterBank = 14;
 sFilterConfig.FilterMode = CAN_FILTERMODE_IDMASK;
 sFilterConfig.FilterScale = CAN_FILTERSCALE_32BIT;
 sFilterConfig.FilterIdHigh   = 0x0000;
 sFilterConfig.FilterIdLow    = 0x0000;
 sFilterConfig.FilterMaskIdHigh = 0x0000;
 sFilterConfig.FilterMaskIdLow  = 0x0000;
 sFilterConfig.FilterFIFOAssignment = CAN_RX_FIFO0;
 sFilterConfig.FilterActivation     = ENABLE;
 sFilterConfig.SlaveStartFilterBank  = 14;
 if (HAL_CAN_ConfigFilter(&hcan2, &sFilterConfig) != HAL_OK) {
   Error_Handler();
 }
 /* USER CODE END CAN2_Init 2 */
}
/**
 * @brief RTC Initialization Function
 * @param None
 * @retval None
 */
static void MX_RTC_Init(void)
{
 /* USER CODE BEGIN RTC_Init 0 */
 /* USER CODE END RTC_Init 0 */
 RTC_TimeTypeDef sTime = {0};
 RTC_DateTypeDef sDate = {0};
 /* USER CODE BEGIN RTC_Init 1 */
 /* USER CODE END RTC_Init 1 */
 /** Initialize RTC Only
 */
 hrtc.Instance = RTC;
 hrtc.Init.HourFormat = RTC_HOURFORMAT_24;
 hrtc.Init.AsynchPrediv = 127;
 hrtc.Init.SynchPrediv = 255;
 hrtc.Init.OutPut = RTC_OUTPUT_DISABLE;
 hrtc.Init.OutPutPolarity = RTC_OUTPUT_POLARITY_HIGH;
 hrtc.Init.OutPutType = RTC_OUTPUT_TYPE_OPENDRAIN;
 if (HAL_RTC_Init(&hrtc) != HAL_OK)
 {
   Error_Handler();
 }
 /* USER CODE BEGIN Check_RTC_BKUP */
 /* USER CODE END Check_RTC_BKUP */
 /** Initialize RTC and set the Time and Date
 */
 sTime.Hours = 0x0;
 sTime.Minutes = 0x0;
 sTime.Seconds = 0x0;
 sTime.DayLightSaving = RTC_DAYLIGHTSAVING_NONE;
 sTime.StoreOperation = RTC_STOREOPERATION_RESET;
 if (HAL_RTC_SetTime(&hrtc, &sTime, RTC_FORMAT_BCD) != HAL_OK)
 {
   Error_Handler();
 }
 sDate.WeekDay = RTC_WEEKDAY_MONDAY;
 sDate.Month = RTC_MONTH_JANUARY;
 sDate.Date = 0x1;
 sDate.Year = 0x0;
 if (HAL_RTC_SetDate(&hrtc, &sDate, RTC_FORMAT_BCD) != HAL_OK)
 {
   Error_Handler();
 }
 /* USER CODE BEGIN RTC_Init 2 */
 /* USER CODE END RTC_Init 2 */
}
/**
 * @brief SPI1 Initialization Function
 * @param None
 * @retval None
 */
static void MX_SPI1_Init(void)
{
 /* USER CODE BEGIN SPI1_Init 0 */
 /* USER CODE END SPI1_Init 0 */
 /* USER CODE BEGIN SPI1_Init 1 */
 /* USER CODE END SPI1_Init 1 */
 /* SPI1 parameter configuration*/
 hspi1.Instance = SPI1;
 hspi1.Init.Mode = SPI_MODE_MASTER;
 hspi1.Init.Direction = SPI_DIRECTION_2LINES;
 hspi1.Init.DataSize = SPI_DATASIZE_8BIT;
 hspi1.Init.CLKPolarity = SPI_POLARITY_LOW;
 hspi1.Init.CLKPhase = SPI_PHASE_1EDGE;
 hspi1.Init.NSS = SPI_NSS_SOFT;
 hspi1.Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_4;
 hspi1.Init.FirstBit = SPI_FIRSTBIT_MSB;
 hspi1.Init.TIMode = SPI_TIMODE_DISABLE;
 hspi1.Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
 hspi1.Init.CRCPolynomial = 10;
 if (HAL_SPI_Init(&hspi1) != HAL_OK)
 {
   Error_Handler();
 }
 /* USER CODE BEGIN SPI1_Init 2 */
 /* USER CODE END SPI1_Init 2 */
}
/**
 * @brief TIM2 Initialization Function
 * @param None
 * @retval None
 */
static void MX_TIM2_Init(void)
{
 /* USER CODE BEGIN TIM2_Init 0 */
 /* USER CODE END TIM2_Init 0 */
 TIM_MasterConfigTypeDef sMasterConfig = {0};
 TIM_OC_InitTypeDef sConfigOC = {0};
 /* USER CODE BEGIN TIM2_Init 1 */
 /* USER CODE END TIM2_Init 1 */
 htim2.Instance = TIM2;
 htim2.Init.Prescaler = 83;
 htim2.Init.CounterMode = TIM_COUNTERMODE_UP;
 htim2.Init.Period = 19999;
 htim2.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
 htim2.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_ENABLE;
 if (HAL_TIM_PWM_Init(&htim2) != HAL_OK)
 {
   Error_Handler();
 }
 sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
 sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
 if (HAL_TIMEx_MasterConfigSynchronization(&htim2, &sMasterConfig) != HAL_OK)
 {
   Error_Handler();
 }
 sConfigOC.OCMode = TIM_OCMODE_PWM1;
 sConfigOC.Pulse = 0;
 sConfigOC.OCPolarity = TIM_OCPOLARITY_HIGH;
 sConfigOC.OCFastMode = TIM_OCFAST_DISABLE;
 if (HAL_TIM_PWM_ConfigChannel(&htim2, &sConfigOC, TIM_CHANNEL_1) != HAL_OK)
 {
   Error_Handler();
 }
 if (HAL_TIM_PWM_ConfigChannel(&htim2, &sConfigOC, TIM_CHANNEL_2) != HAL_OK)
 {
   Error_Handler();
 }
 /* USER CODE BEGIN TIM2_Init 2 */
 /* USER CODE END TIM2_Init 2 */
 HAL_TIM_MspPostInit(&htim2);
}
/**
 * Enable DMA controller clock
 */
static void MX_DMA_Init(void)
{
 /* DMA controller clock enable */
 __HAL_RCC_DMA2_CLK_ENABLE();
 /* DMA interrupt init */
 /* DMA2_Stream3_IRQn interrupt configuration */
 HAL_NVIC_SetPriority(DMA2_Stream3_IRQn, 0, 0);
 HAL_NVIC_EnableIRQ(DMA2_Stream3_IRQn);
}
/**
 * @brief GPIO Initialization Function
 * @param None
 * @retval None
 */
static void MX_GPIO_Init(void)
{
 GPIO_InitTypeDef GPIO_InitStruct = {0};
 /* USER CODE BEGIN MX_GPIO_Init_1 */
 /* USER CODE END MX_GPIO_Init_1 */
 /* GPIO Ports Clock Enable */
 __HAL_RCC_GPIOH_CLK_ENABLE();
 __HAL_RCC_GPIOA_CLK_ENABLE();
 __HAL_RCC_GPIOE_CLK_ENABLE();
 __HAL_RCC_GPIOB_CLK_ENABLE();
 /*Configure GPIO pin Output Level */
 HAL_GPIO_WritePin(GPIOE, CS_Pin|DC_Pin|RESET_Pin, GPIO_PIN_RESET);
 /*Configure GPIO pins : CS_Pin DC_Pin RESET_Pin */
 GPIO_InitStruct.Pin = CS_Pin|DC_Pin|RESET_Pin;
 GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 GPIO_InitStruct.Pull = GPIO_NOPULL;
 GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 HAL_GPIO_Init(GPIOE, &GPIO_InitStruct);
 /* USER CODE BEGIN MX_GPIO_Init_2 */
 /* USER CODE END MX_GPIO_Init_2 */
}
/* USER CODE BEGIN 4 */
/* (none) */
/* USER CODE END 4 */
/**
 * @brief  This function is executed in case of error occurrence.
 * @retval None
 */
void Error_Handler(void)
{
 /* USER CODE BEGIN Error_Handler_Debug */
 /* User can add his own implementation to report the HAL error return state */
 __disable_irq();
 while (1)
 {
 }
 /* USER CODE END Error_Handler_Debug */
}
#ifdef  USE_FULL_ASSERT
/**
 * @brief  Reports the name of the source file and the source line number
 *         where the assert_param error has occurred.
 * @param  file: pointer to the source file name
 * @param  line: assert_param error line source number
 * @retval None
 */
void assert_failed(uint8_t *file, uint32_t line)
{
 /* USER CODE BEGIN 6 */
 /* User can add his own implementation to report the file name and line number,
    ex: printf("Wrong parameters value: file %s on line %d\r\n", file, line) */
 /* USER CODE END 6 */
}
#endif /* USE_FULL_ASSERT */

